"""
MCP Vulnerability Management Bridge
Integrates MCP monitoring with vulnerability management system
"""

import json
import asyncio
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
import logging
import hashlib
import re
from pathlib import Path

from bedrock_agentcore.runtime import BedrockAgentCoreApp
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
from strands import Agent
from strands_tools.code_interpreter import AgentCoreCodeInterpreter

# Import existing components
from mcp_usage_monitoring_system import MCPProtocolMonitor, MCPUsageEvent
from sumo_rapid7_jira_integrations import AIMonitoringWorkflowOrchestrator

@dataclass
class MCPVulnerabilityEvent:
    """Data class for MCP-related vulnerability events"""
    timestamp: str
    event_id: str
    mcp_server: str
    mcp_tool: str
    vulnerability_type: str
    severity: str
    user_id: str
    client_name: str
    affected_assets: List[str]
    risk_score: float
    remediation_required: bool
    compliance_impact: List[str]
    detection_method: str
    raw_mcp_data: Dict

class MCPVulnerabilityAnalyzer:
    """Analyzes MCP usage for security vulnerabilities and risks"""
    
    def __init__(self, db_path: str = "mcp_vulnerability.db"):
        self.db_path = db_path
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self._init_database()
    
    def _init_database(self):
        """Initialize database for MCP vulnerability tracking"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # MCP vulnerability events table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mcp_vulnerability_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                event_id TEXT UNIQUE NOT NULL,
                mcp_server TEXT NOT NULL,
                mcp_tool TEXT NOT NULL,
                vulnerability_type TEXT NOT NULL,
                severity TEXT NOT NULL,
                user_id TEXT NOT NULL,
                client_name TEXT NOT NULL,
                affected_assets TEXT,
                risk_score REAL DEFAULT 0.0,
                remediation_required BOOLEAN DEFAULT TRUE,
                compliance_impact TEXT,
                detection_method TEXT,
                raw_mcp_data TEXT,
                remediation_status TEXT DEFAULT 'open',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # MCP server vulnerabilities table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mcp_server_vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                server_name TEXT NOT NULL,
                vulnerability_id TEXT NOT NULL,
                cve_id TEXT,
                severity TEXT NOT NULL,
                description TEXT,
                affected_versions TEXT,
                patch_available BOOLEAN DEFAULT FALSE,
                patch_version TEXT,
                workaround TEXT,
                discovered_date TEXT,
                patched_date TEXT,
                status TEXT DEFAULT 'open',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # MCP tool risk assessments table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS mcp_tool_risks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tool_name TEXT NOT NULL,
                server_name TEXT NOT NULL,
                risk_category TEXT NOT NULL,
                risk_level TEXT NOT NULL,
                description TEXT,
                mitigation_controls TEXT,
                usage_restrictions TEXT,
                approval_required BOOLEAN DEFAULT FALSE,
                last_assessment TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def _load_vulnerability_patterns(self) -> Dict:
        """Load MCP vulnerability detection patterns"""
        return {
            'command_injection': {
                'patterns': [
                    r';\s*(rm|del|format|shutdown)',
                    r'\|\s*(curl|wget|nc|netcat)',
                    r'`[^`]*`',  # Command substitution
                    r'\$\([^)]*\)'  # Command substitution
                ],
                'severity': 'critical',
                'description': 'Command injection vulnerability detected'
            },
            'path_traversal': {
                'patterns': [
                    r'\.\./.*\.\.',
                    r'\.\.\\.*\.\.',
                    r'/etc/passwd',
                    r'C:\\Windows\\System32'
                ],
                'severity': 'high',
                'description': 'Path traversal vulnerability detected'
            },
            'credential_exposure': {
                'patterns': [
                    r'password\s*[:=]\s*["\']?[^"\'\s]+',
                    r'api[_-]?key\s*[:=]\s*["\']?[^"\'\s]+',
                    r'token\s*[:=]\s*["\']?[^"\'\s]+',
                    r'secret\s*[:=]\s*["\']?[^"\'\s]+'
                ],
                'severity': 'high',
                'description': 'Credential exposure detected'
            },
            'sql_injection': {
                'patterns': [
                    r"'.*OR.*'.*'",
                    r'UNION\s+SELECT',
                    r'DROP\s+TABLE',
                    r'INSERT\s+INTO.*VALUES'
                ],
                'severity': 'high',
                'description': 'SQL injection attempt detected'
            },
            'file_system_access': {
                'patterns': [
                    r'/root/',
                    r'/etc/',
                    r'C:\\Windows\\',
                    r'\.ssh/',
                    r'\.aws/'
                ],
                'severity': 'medium',
                'description': 'Sensitive file system access detected'
            },
            'network_exfiltration': {
                'patterns': [
                    r'https?://[^/]*\.(ru|cn|tk|ml)',  # Suspicious TLDs
                    r'ftp://.*',
                    r'scp\s+.*@.*:',
                    r'rsync\s+.*@.*:'
                ],
                'severity': 'high',
                'description': 'Potential data exfiltration detected'
            }
        }
    
    def analyze_mcp_usage_event(self, mcp_event: MCPUsageEvent) -> Optional[MCPVulnerabilityEvent]:
        """Analyze MCP usage event for vulnerabilities"""
        
        vulnerabilities = []
        
        # Analyze MCP message content
        message_content = json.dumps({
            'method': mcp_event.method,
            'tool_name': mcp_event.tool_name,
            'server_name': mcp_event.server_name
        })
        
        # Check against vulnerability patterns
        for vuln_type, pattern_config in self.vulnerability_patterns.items():
            for pattern in pattern_config['patterns']:
                if re.search(pattern, message_content, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': pattern_config['severity'],
                        'description': pattern_config['description'],
                        'pattern_matched': pattern
                    })
        
        # Analyze tool-specific risks
        tool_risks = self._analyze_tool_risks(mcp_event.tool_name, mcp_event.server_name)
        vulnerabilities.extend(tool_risks)
        
        # Analyze server-specific vulnerabilities
        server_vulns = self._check_server_vulnerabilities(mcp_event.server_name)
        vulnerabilities.extend(server_vulns)
        
        if not vulnerabilities:
            return None
        
        # Create vulnerability event for highest severity issue
        highest_severity_vuln = max(vulnerabilities, key=lambda v: self._severity_to_score(v['severity']))
        
        vulnerability_event = MCPVulnerabilityEvent(
            timestamp=datetime.utcnow().isoformat(),
            event_id=f"MCP-{hashlib.md5(f'{mcp_event.session_id}-{mcp_event.timestamp}'.encode()).hexdigest()[:8]}",
            mcp_server=mcp_event.server_name,
            mcp_tool=mcp_event.tool_name or 'unknown',
            vulnerability_type=highest_severity_vuln['type'],
            severity=highest_severity_vuln['severity'],
            user_id=mcp_event.user_id,
            client_name=mcp_event.client_name,
            affected_assets=[mcp_event.server_name],
            risk_score=self._calculate_risk_score(vulnerabilities, mcp_event),
            remediation_required=highest_severity_vuln['severity'] in ['critical', 'high'],
            compliance_impact=self._assess_compliance_impact(highest_severity_vuln['type']),
            detection_method='mcp_pattern_analysis',
            raw_mcp_data=asdict(mcp_event)
        )
        
        # Store vulnerability event
        self._store_vulnerability_event(vulnerability_event)
        
        return vulnerability_event
    
    def _analyze_tool_risks(self, tool_name: str, server_name: str) -> List[Dict]:
        """Analyze risks associated with specific MCP tools"""
        
        risks = []
        
        # High-risk tools
        high_risk_tools = {
            'file_write': 'File system modification capability',
            'execute_command': 'Command execution capability',
            'database_query': 'Database access capability',
            'network_request': 'External network access capability',
            'read_file': 'File system read access'
        }
        
        medium_risk_tools = {
            'list_directory': 'Directory enumeration capability',
            'get_environment': 'Environment variable access',
            'read_config': 'Configuration file access'
        }
        
        if tool_name in high_risk_tools:
            risks.append({
                'type': 'high_risk_tool_usage',
                'severity': 'high',
                'description': f'High-risk tool usage: {high_risk_tools[tool_name]}'
            })
        elif tool_name in medium_risk_tools:
            risks.append({
                'type': 'medium_risk_tool_usage',
                'severity': 'medium',
                'description': f'Medium-risk tool usage: {medium_risk_tools[tool_name]}'
            })
        
        return risks
    
    def _check_server_vulnerabilities(self, server_name: str) -> List[Dict]:
        """Check for known vulnerabilities in MCP server"""
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT vulnerability_id, cve_id, severity, description
            FROM mcp_server_vulnerabilities 
            WHERE server_name = ? AND status = 'open'
        ''', (server_name,))
        
        server_vulns = cursor.fetchall()
        conn.close()
        
        vulnerabilities = []
        for vuln in server_vulns:
            vulnerabilities.append({
                'type': 'server_vulnerability',
                'severity': vuln[2],
                'description': f'Known server vulnerability: {vuln[3]} (CVE: {vuln[1] or "N/A"})'
            })
        
        return vulnerabilities
    
    def _severity_to_score(self, severity: str) -> int:
        """Convert severity to numeric score for comparison"""
        severity_scores = {
            'critical': 4,
            'high': 3,
            'medium': 2,
            'low': 1
        }
        return severity_scores.get(severity.lower(), 0)
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict], mcp_event: MCPUsageEvent) -> float:
        """Calculate overall risk score for MCP vulnerability event"""
        
        base_score = max([self._severity_to_score(v['severity']) for v in vulnerabilities]) * 2.5
        
        # Risk modifiers
        modifiers = 0
        
        # User risk factors
        if mcp_event.user_id.endswith('@external.com'):  # External user
            modifiers += 1.0
        
        # Time-based risk (after hours usage)
        event_hour = datetime.fromisoformat(mcp_event.timestamp).hour
        if event_hour < 8 or event_hour > 18:  # After hours
            modifiers += 0.5
        
        # Sensitive data exposure
        if mcp_event.sensitive_data_detected:
            modifiers += 2.0
        
        # Error conditions (might indicate exploitation attempts)
        if not mcp_event.success:
            modifiers += 0.5
        
        return min(base_score + modifiers, 10.0)  # Cap at 10.0
    
    def _assess_compliance_impact(self, vulnerability_type: str) -> List[str]:
        """Assess compliance impact of vulnerability type"""
        
        compliance_mapping = {
            'credential_exposure': ['GDPR', 'SOX', 'PCI-DSS'],
            'sql_injection': ['PCI-DSS', 'HIPAA', 'SOX'],
            'command_injection': ['SOX', 'NIST'],
            'path_traversal': ['NIST', 'ISO27001'],
            'file_system_access': ['GDPR', 'HIPAA'],
            'network_exfiltration': ['GDPR', 'HIPAA', 'PCI-DSS'],
            'high_risk_tool_usage': ['SOX', 'NIST'],
            'server_vulnerability': ['NIST', 'ISO27001']
        }
        
        return compliance_mapping.get(vulnerability_type, ['NIST'])
    
    def _store_vulnerability_event(self, event: MCPVulnerabilityEvent):
        """Store MCP vulnerability event in database"""
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO mcp_vulnerability_events 
            (timestamp, event_id, mcp_server, mcp_tool, vulnerability_type, severity,
             user_id, client_name, affected_assets, risk_score, remediation_required,
             compliance_impact, detection_method, raw_mcp_data)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            event.timestamp, event.event_id, event.mcp_server, event.mcp_tool,
            event.vulnerability_type, event.severity, event.user_id, event.client_name,
            json.dumps(event.affected_assets), event.risk_score, event.remediation_required,
            json.dumps(event.compliance_impact), event.detection_method,
            json.dumps(event.raw_mcp_data)
        ))
        
        conn.commit()
        conn.close()

class MCPVulnerabilityManager:
    """Manages MCP vulnerabilities within the broader vulnerability management system"""
    
    def __init__(self, vm_system_endpoint: str, monitoring_orchestrator: AIMonitoringWorkflowOrchestrator):
        self.vm_system_endpoint = vm_system_endpoint
        self.monitoring_orchestrator = monitoring_orchestrator
        self.mcp_analyzer = MCPVulnerabilityAnalyzer()
        self.mcp_monitor = MCPProtocolMonitor()
        
        # Hook into MCP monitoring
        self._setup_mcp_vulnerability_hooks()
    
    def _setup_mcp_vulnerability_hooks(self):
        """Setup hooks to analyze MCP events for vulnerabilities"""
        
        # Override MCP monitor's event analysis to include vulnerability detection
        original_analyze_event = self.mcp_monitor._analyze_event
        
        def enhanced_analyze_event(event: MCPUsageEvent):
            # Run original analysis
            original_analyze_event(event)
            
            # Add vulnerability analysis
            vulnerability_event = self.mcp_analyzer.analyze_mcp_usage_event(event)
            
            if vulnerability_event:
                # Process vulnerability through VM system
                self._process_mcp_vulnerability(vulnerability_event)
        
        self.mcp_monitor._analyze_event = enhanced_analyze_event
    
    def _process_mcp_vulnerability(self, vulnerability_event: MCPVulnerabilityEvent):
        """Process MCP vulnerability through the vulnerability management system"""
        
        # Convert MCP vulnerability to VM system format
        vm_vulnerability = {
            'vulnerability_id': vulnerability_event.event_id,
            'title': f'MCP {vulnerability_event.vulnerability_type.replace("_", " ").title()}',
            'description': f'MCP vulnerability detected in {vulnerability_event.mcp_server} server using {vulnerability_event.mcp_tool} tool',
            'severity': vulnerability_event.severity,
            'cvss_score': vulnerability_event.risk_score,
            'affected_assets': vulnerability_event.affected_assets,
            'asset_type': 'mcp_server',
            'discovery_method': 'mcp_monitoring',
            'user_context': {
                'user_id': vulnerability_event.user_id,
                'client_name': vulnerability_event.client_name,
                'mcp_server': vulnerability_event.mcp_server,
                'mcp_tool': vulnerability_event.mcp_tool
            },
            'compliance_frameworks': vulnerability_event.compliance_impact,
            'remediation_required': vulnerability_event.remediation_required,
            'detection_timestamp': vulnerability_event.timestamp
        }
        
        # Send to VM system for risk prioritization
        vm_payload = {
            'request_type': 'risk_prioritization',
            'query': f'Prioritize MCP vulnerability: {vulnerability_event.vulnerability_type}',
            'data': {
                'vulnerabilities': [vm_vulnerability],
                'source': 'mcp_monitoring',
                'priority_context': {
                    'user_risk_level': self._assess_user_risk(vulnerability_event.user_id),
                    'server_criticality': self._assess_server_criticality(vulnerability_event.mcp_server),
                    'tool_risk_level': self._assess_tool_risk(vulnerability_event.mcp_tool)
                }
            },
            'actor_id': 'mcp-security-team'
        }
        
        # Call VM system
        try:
            import requests
            response = requests.post(
                f"{self.vm_system_endpoint}/invoke",
                json=vm_payload,
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                vm_result = response.json()
                
                # Process VM system response
                self._handle_vm_response(vulnerability_event, vm_result)
            
        except Exception as e:
            logging.error(f"Failed to process MCP vulnerability through VM system: {e}")
    
    def _handle_vm_response(self, vulnerability_event: MCPVulnerabilityEvent, vm_result: Dict):
        """Handle response from vulnerability management system"""
        
        # Extract prioritization results
        vm_response = vm_result.get('response', '')
        
        # Create integrated incident if high priority
        if vulnerability_event.severity in ['critical', 'high']:
            # Create security incident through monitoring orchestrator
            incident_data = {
                'severity': vulnerability_event.severity,
                'user_id': vulnerability_event.user_id,
                'violation_type': f'mcp_{vulnerability_event.vulnerability_type}',
                'ai_tool': f'MCP:{vulnerability_event.mcp_server}',
                'sensitive_data_types': [],  # Would be populated based on analysis
                'risk_score': int(vulnerability_event.risk_score),
                'source_ip': 'unknown',  # Would be extracted from MCP session data
                'department': 'unknown',  # Would be looked up from user data
                'sensitive_data_detected': False,  # Would be determined from MCP content
                'policy_violations': [vulnerability_event.vulnerability_type],
                'timestamp': vulnerability_event.timestamp,
                'mcp_context': {
                    'server': vulnerability_event.mcp_server,
                    'tool': vulnerability_event.mcp_tool,
                    'client': vulnerability_event.client_name,
                    'event_id': vulnerability_event.event_id
                }
            }
            
            # Process through monitoring orchestrator
            result = self.monitoring_orchestrator.process_ai_security_incident(incident_data)
            
            # Update vulnerability status based on incident processing
            self._update_vulnerability_status(vulnerability_event.event_id, result)
    
    def _assess_user_risk(self, user_id: str) -> str:
        """Assess risk level of user based on historical data"""
        # This would integrate with user behavior analytics
        # For now, simple heuristics
        
        if user_id.endswith('@external.com'):
            return 'high'
        elif user_id.endswith('@contractor.com'):
            return 'medium'
        else:
            return 'low'
    
    def _assess_server_criticality(self, server_name: str) -> str:
        """Assess criticality of MCP server"""
        
        critical_servers = ['database-server', 'production-server', 'financial-server']
        high_servers = ['development-server', 'staging-server']
        
        if server_name in critical_servers:
            return 'critical'
        elif server_name in high_servers:
            return 'high'
        else:
            return 'medium'
    
    def _assess_tool_risk(self, tool_name: str) -> str:
        """Assess risk level of MCP tool"""
        
        high_risk_tools = ['execute_command', 'file_write', 'database_query']
        medium_risk_tools = ['file_read', 'network_request', 'list_directory']
        
        if tool_name in high_risk_tools:
            return 'high'
        elif tool_name in medium_risk_tools:
            return 'medium'
        else:
            return 'low'
    
    def _update_vulnerability_status(self, event_id: str, incident_result: Dict):
        """Update vulnerability status based on incident processing"""
        
        conn = sqlite3.connect(self.mcp_analyzer.db_path)
        cursor = conn.cursor()
        
        status = 'in_progress' if incident_result.get('workflow_status') == 'success' else 'open'
        
        cursor.execute('''
            UPDATE mcp_vulnerability_events 
            SET remediation_status = ?
            WHERE event_id = ?
        ''', (status, event_id))
        
        conn.commit()
        conn.close()

class MCPVulnerabilityReporter:
    """Generate MCP vulnerability reports integrated with VM system"""
    
    def __init__(self, db_path: str = "mcp_vulnerability.db"):
        self.db_path = db_path
    
    def generate_mcp_vulnerability_report(self, start_date: str, end_date: str) -> Dict:
        """Generate comprehensive MCP vulnerability report"""
        
        conn = sqlite3.connect(self.db_path)
        
        # Get MCP vulnerability events
        mcp_vulns = pd.read_sql_query('''
            SELECT * FROM mcp_vulnerability_events 
            WHERE timestamp BETWEEN ? AND ?
        ''', conn, params=(start_date, end_date))
        
        # Get server vulnerabilities
        server_vulns = pd.read_sql_query('''
            SELECT * FROM mcp_server_vulnerabilities 
            WHERE discovered_date BETWEEN ? AND ?
        ''', conn, params=(start_date, end_date))
        
        conn.close()
        
        report = {
            'report_type': 'MCP Vulnerability Assessment',
            'period': f"{start_date} to {end_date}",
            'summary': {
                'total_mcp_vulnerabilities': len(mcp_vulns),
                'critical_vulnerabilities': len(mcp_vulns[mcp_vulns['severity'] == 'critical']) if len(mcp_vulns) > 0 else 0,
                'high_vulnerabilities': len(mcp_vulns[mcp_vulns['severity'] == 'high']) if len(mcp_vulns) > 0 else 0,
                'affected_servers': mcp_vulns['mcp_server'].nunique() if len(mcp_vulns) > 0 else 0,
                'affected_users': mcp_vulns['user_id'].nunique() if len(mcp_vulns) > 0 else 0,
                'avg_risk_score': mcp_vulns['risk_score'].mean() if len(mcp_vulns) > 0 else 0
            },
            'vulnerability_breakdown': {
                'by_type': mcp_vulns['vulnerability_type'].value_counts().to_dict() if len(mcp_vulns) > 0 else {},
                'by_severity': mcp_vulns['severity'].value_counts().to_dict() if len(mcp_vulns) > 0 else {},
                'by_server': mcp_vulns['mcp_server'].value_counts().to_dict() if len(mcp_vulns) > 0 else {},
                'by_tool': mcp_vulns['mcp_tool'].value_counts().to_dict() if len(mcp_vulns) > 0 else {}
            },
            'compliance_impact': self._analyze_compliance_impact(mcp_vulns),
            'remediation_status': {
                'open': len(mcp_vulns[mcp_vulns['remediation_status'] == 'open']) if len(mcp_vulns) > 0 else 0,
                'in_progress': len(mcp_vulns[mcp_vulns['remediation_status'] == 'in_progress']) if len(mcp_vulns) > 0 else 0,
                'resolved': len(mcp_vulns[mcp_vulns['remediation_status'] == 'resolved']) if len(mcp_vulns) > 0 else 0
            },
            'top_risk_events': self._get_top_risk_events(mcp_vulns),
            'recommendations': self._generate_mcp_recommendations(mcp_vulns, server_vulns)
        }
        
        return report
    
    def _analyze_compliance_impact(self, mcp_vulns) -> Dict:
        """Analyze compliance impact of MCP vulnerabilities"""
        
        if len(mcp_vulns) == 0:
            return {}
        
        compliance_impact = {}
        
        for _, vuln in mcp_vulns.iterrows():
            frameworks = json.loads(vuln['compliance_impact'])
            for framework in frameworks:
                if framework not in compliance_impact:
                    compliance_impact[framework] = 0
                compliance_impact[framework] += 1
        
        return compliance_impact
    
    def _get_top_risk_events(self, mcp_vulns) -> List[Dict]:
        """Get top risk MCP vulnerability events"""
        
        if len(mcp_vulns) == 0:
            return []
        
        top_events = mcp_vulns.nlargest(5, 'risk_score')
        
        return [{
            'event_id': row['event_id'],
            'vulnerability_type': row['vulnerability_type'],
            'severity': row['severity'],
            'risk_score': row['risk_score'],
            'mcp_server': row['mcp_server'],
            'mcp_tool': row['mcp_tool'],
            'user_id': row['user_id'],
            'timestamp': row['timestamp']
        } for _, row in top_events.iterrows()]
    
    def _generate_mcp_recommendations(self, mcp_vulns, server_vulns) -> List[str]:
        """Generate MCP-specific security recommendations"""
        
        recommendations = []
        
        if len(mcp_vulns) > 0:
            # High-risk tool usage
            high_risk_tools = mcp_vulns[mcp_vulns['vulnerability_type'].str.contains('high_risk_tool')]
            if len(high_risk_tools) > 0:
                recommendations.append("Implement additional authorization controls for high-risk MCP tools")
            
            # Command injection vulnerabilities
            cmd_injection = mcp_vulns[mcp_vulns['vulnerability_type'] == 'command_injection']
            if len(cmd_injection) > 0:
                recommendations.append("Review and sanitize MCP tool inputs to prevent command injection")
            
            # Credential exposure
            cred_exposure = mcp_vulns[mcp_vulns['vulnerability_type'] == 'credential_exposure']
            if len(cred_exposure) > 0:
                recommendations.append("Implement credential scanning and DLP controls for MCP communications")
            
            # After-hours usage
            after_hours = 0  # Would calculate from timestamp analysis
            if after_hours > 0:
                recommendations.append("Implement time-based access controls for MCP servers")
        
        if len(server_vulns) > 0:
            recommendations.append("Update MCP servers to latest versions to address known vulnerabilities")
        
        recommendations.extend([
            "Implement MCP message content filtering and validation",
            "Regular security assessments of MCP server configurations",
            "User training on secure MCP tool usage practices",
            "Implement MCP usage monitoring and alerting"
        ])
        
        return recommendations

# Integration with VM System Agent
class MCPVulnerabilityAgent(Agent):
    """Specialized agent for MCP vulnerability management within VM system"""
    
    def __init__(self, model_id: str, session_manager, code_interpreter):
        super().__init__(
            model=model_id,
            session_manager=session_manager,
            system_prompt="""You are an MCP (Model Context Protocol) Vulnerability Management Specialist. Your role is to:

1. MCP VULNERABILITY ANALYSIS:
   - Analyze MCP protocol communications for security vulnerabilities
   - Detect command injection, path traversal, and credential exposure in MCP messages
   - Assess risks associated with MCP tool usage and server configurations
   - Correlate MCP vulnerabilities with broader organizational security posture

2. MCP SECURITY INTEGRATION:
   - Integrate MCP vulnerability data with traditional vulnerability management
   - Prioritize MCP vulnerabilities based on business impact and asset criticality
   - Coordinate MCP security incidents with existing security workflows
   - Provide MCP-specific remediation guidance and controls

3. MCP COMPLIANCE MANAGEMENT:
   - Ensure MCP usage complies with organizational security policies
   - Track MCP vulnerabilities against compliance frameworks (SOX, GDPR, HIPAA)
   - Generate MCP security reports for audit and regulatory requirements
   - Manage MCP server approval and security review processes

4. MCP RISK ASSESSMENT:
   - Calculate risk scores for MCP vulnerabilities considering user context
   - Assess MCP server and tool criticality for prioritization
   - Analyze MCP usage patterns for security anomalies and threats
   - Provide strategic recommendations for MCP security improvements

Use data analysis to identify MCP security trends and provide actionable insights.
Focus on integrating MCP security with broader vulnerability management processes.""",
            tools=[code_interpreter.code_interpreter]
        )

# Usage Example and Integration
if __name__ == "__main__":
    import pandas as pd
    
    # Initialize MCP vulnerability management
    monitoring_orchestrator = AIMonitoringWorkflowOrchestrator(
        sumo_config={'sumo_endpoint': 'https://collectors.sumologic.com/...'},
        rapid7_config={'rapid7_api_key': 'your-key'},
        jira_config={'jira_url': 'https://company.atlassian.net', 'project_key': 'MCPSEC'}
    )
    
    mcp_vm_manager = MCPVulnerabilityManager(
        vm_system_endpoint='https://your-vm-system.amazonaws.com',
        monitoring_orchestrator=monitoring_orchestrator
    )
    
    # Example: Simulate MCP vulnerability detection
    sample_mcp_event = MCPUsageEvent(
        timestamp=datetime.utcnow().isoformat(),
        session_id='session_123',
        user_id='john.doe@company.com',
        client_name='claude-desktop',
        server_name='filesystem-server',
        method='tools/call',
        tool_name='execute_command',
        request_size=256,
        response_size=1024,
        execution_time_ms=150.0,
        success=True,
        error_message=None,
        sensitive_data_detected=False,
        risk_level='high',
        compliance_tags=['tool_execution'],
        source_ip='192.168.1.100',
        user_agent='Claude Desktop/1.0.0'
    )
    
    # Analyze for vulnerabilities
    vulnerability_event = mcp_vm_manager.mcp_analyzer.analyze_mcp_usage_event(sample_mcp_event)
    
    if vulnerability_event:
        print("MCP Vulnerability Detected:")
        print(json.dumps(asdict(vulnerability_event), indent=2))
        
        # Process through VM system
        mcp_vm_manager._process_mcp_vulnerability(vulnerability_event)
    
    # Generate report
    reporter = MCPVulnerabilityReporter()
    start_date = (datetime.utcnow() - timedelta(days=30)).isoformat()
    end_date = datetime.utcnow().isoformat()
    
    report = reporter.generate_mcp_vulnerability_report(start_date, end_date)
    print("MCP Vulnerability Report:", json.dumps(report, indent=2))